---
phase: 02-video-retrieval
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - supabase/functions/fetch-channel-videos/index.ts
autonomous: true
user_setup:
  - service: youtube-data-api
    why: "Fetch channel videos from YouTube"
    env_vars:
      - name: YOUTUBE_API_KEY
        source: "Google Cloud Console -> APIs & Services -> Credentials -> Create API key"
    dashboard_config:
      - task: "Enable YouTube Data API v3"
        location: "Google Cloud Console -> APIs & Services -> Library -> Search 'YouTube Data API v3' -> Enable"
      - task: "Restrict API key (optional but recommended)"
        location: "Google Cloud Console -> APIs & Services -> Credentials -> Edit key -> Add API restrictions -> YouTube Data API v3"

must_haves:
  truths:
    - "Edge Function fetches videos from YouTube API"
    - "Only long-form videos (>= 180 seconds) are returned"
    - "Videos are cached in database with fetched_at timestamp"
    - "24-hour cache is respected (no API call if cache fresh)"
    - "Channel name is updated from API response"
  artifacts:
    - path: "supabase/functions/fetch-channel-videos/index.ts"
      provides: "YouTube API integration with caching"
      min_lines: 100
  key_links:
    - from: "supabase/functions/fetch-channel-videos/index.ts"
      to: "YouTube Data API v3"
      via: "fetch to googleapis.com"
      pattern: "googleapis\\.com/youtube/v3"
    - from: "supabase/functions/fetch-channel-videos/index.ts"
      to: "videos table"
      via: "supabase.from('videos').upsert"
      pattern: "from\\(['\"]videos['\"]\\)"
---

<objective>
Create Supabase Edge Function to fetch channel videos from YouTube API with caching.

Purpose: Server-side YouTube API integration keeps API key secure, enables caching, and manages quota. The three-step fetch pattern (channels.list -> playlistItems.list -> videos.list) uses only 3 quota units per refresh.

Output: Edge Function that accepts channelId and youtubeChannelId, returns filtered long-form videos, and updates database cache.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-video-retrieval/02-RESEARCH.md

# Database schema from plan 01
@supabase/migrations/002_create_videos.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create fetch-channel-videos Edge Function</name>
  <files>supabase/functions/fetch-channel-videos/index.ts</files>
  <action>
Create Edge Function at supabase/functions/fetch-channel-videos/index.ts.

First ensure the functions directory exists:
```bash
mkdir -p supabase/functions/fetch-channel-videos
```

Write the Edge Function:

```typescript
import { serve } from 'https://deno.land/std@0.168.0/http/server.ts'
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2'
import { parse, toSeconds } from 'https://esm.sh/iso8601-duration@2'

const YOUTUBE_API_KEY = Deno.env.get('YOUTUBE_API_KEY')!
const SUPABASE_URL = Deno.env.get('SUPABASE_URL')!
const SUPABASE_SERVICE_ROLE_KEY = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!

const SHORTS_THRESHOLD = 180 // Shorts are < 180 seconds (3 minutes)
const CACHE_TTL_MS = 24 * 60 * 60 * 1000 // 24 hours

interface VideoInsert {
  channel_id: string
  youtube_id: string
  title: string
  thumbnail_url: string
  duration_seconds: number
  view_count: number
  published_at: string
  fetched_at: string
}

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
}

serve(async (req) => {
  // Handle CORS preflight
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders })
  }

  try {
    const { channelId, youtubeChannelId, forceRefresh } = await req.json()

    if (!channelId || !youtubeChannelId) {
      return new Response(
        JSON.stringify({ error: 'channelId and youtubeChannelId are required' }),
        { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      )
    }

    const supabase = createClient(SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY)

    // Check cache freshness (unless forceRefresh is true)
    if (!forceRefresh) {
      const { data: cached } = await supabase
        .from('videos')
        .select('fetched_at')
        .eq('channel_id', channelId)
        .order('fetched_at', { ascending: false })
        .limit(1)

      const cacheAge = cached?.[0]
        ? Date.now() - new Date(cached[0].fetched_at).getTime()
        : Infinity

      if (cacheAge < CACHE_TTL_MS) {
        // Return cached videos
        const { data: cachedVideos } = await supabase
          .from('videos')
          .select('*')
          .eq('channel_id', channelId)
          .gte('duration_seconds', SHORTS_THRESHOLD)
          .order('published_at', { ascending: false })
          .limit(20)

        return new Response(
          JSON.stringify({ videos: cachedVideos, cached: true, fetchedAt: cached[0].fetched_at }),
          { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
        )
      }
    }

    // Step 1: Get uploads playlist ID and channel name
    const channelRes = await fetch(
      `https://www.googleapis.com/youtube/v3/channels?` +
      `part=snippet,contentDetails&id=${youtubeChannelId}&key=${YOUTUBE_API_KEY}`
    )

    if (!channelRes.ok) {
      const error = await channelRes.json()
      throw new Error(`YouTube API error: ${error.error?.message || channelRes.statusText}`)
    }

    const channelData = await channelRes.json()

    if (!channelData.items?.length) {
      throw new Error('Channel not found on YouTube')
    }

    const uploadsPlaylistId = channelData.items[0].contentDetails.relatedPlaylists.uploads
    const channelName = channelData.items[0].snippet.title
    const channelThumbnail = channelData.items[0].snippet.thumbnails?.default?.url || null

    // Update channel name and thumbnail in database
    await supabase
      .from('channels')
      .update({
        name: channelName,
        thumbnail_url: channelThumbnail
      })
      .eq('id', channelId)

    // Step 2: Get video IDs from uploads playlist (max 50)
    const playlistRes = await fetch(
      `https://www.googleapis.com/youtube/v3/playlistItems?` +
      `part=contentDetails&playlistId=${uploadsPlaylistId}&maxResults=50&key=${YOUTUBE_API_KEY}`
    )

    if (!playlistRes.ok) {
      const error = await playlistRes.json()
      throw new Error(`YouTube API error: ${error.error?.message || playlistRes.statusText}`)
    }

    const playlistData = await playlistRes.json()

    if (!playlistData.items?.length) {
      return new Response(
        JSON.stringify({ videos: [], cached: false, fetchedAt: new Date().toISOString() }),
        { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      )
    }

    const videoIds = playlistData.items
      .map((item: any) => item.contentDetails.videoId)
      .join(',')

    // Step 3: Get video details with duration
    const videosRes = await fetch(
      `https://www.googleapis.com/youtube/v3/videos?` +
      `part=snippet,contentDetails,statistics&id=${videoIds}&key=${YOUTUBE_API_KEY}`
    )

    if (!videosRes.ok) {
      const error = await videosRes.json()
      throw new Error(`YouTube API error: ${error.error?.message || videosRes.statusText}`)
    }

    const videosData = await videosRes.json()
    const now = new Date().toISOString()

    // Parse, filter Shorts, and transform videos
    const videos: VideoInsert[] = videosData.items
      .map((item: any) => {
        const durationSeconds = toSeconds(parse(item.contentDetails.duration))
        return {
          channel_id: channelId,
          youtube_id: item.id,
          title: item.snippet.title,
          thumbnail_url: item.snippet.thumbnails?.medium?.url || item.snippet.thumbnails?.default?.url,
          duration_seconds: durationSeconds,
          view_count: parseInt(item.statistics.viewCount || '0', 10),
          published_at: item.snippet.publishedAt,
          fetched_at: now,
        }
      })
      .filter((v: VideoInsert) => v.duration_seconds >= SHORTS_THRESHOLD)

    // Upsert videos to database (handles duplicates via youtube_id)
    if (videos.length > 0) {
      const { error: upsertError } = await supabase
        .from('videos')
        .upsert(videos, { onConflict: 'youtube_id' })

      if (upsertError) {
        console.error('Upsert error:', upsertError)
        // Continue - we can still return the videos
      }
    }

    // Return top 20 newest
    const topVideos = videos
      .sort((a, b) => new Date(b.published_at).getTime() - new Date(a.published_at).getTime())
      .slice(0, 20)

    return new Response(
      JSON.stringify({ videos: topVideos, cached: false, fetchedAt: now }),
      { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    )

  } catch (error) {
    console.error('Error:', error)
    return new Response(
      JSON.stringify({ error: error.message || 'Internal server error' }),
      { status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    )
  }
})
```

Key implementation details:
- CORS headers for browser requests
- Cache check before API calls (respects 24hr TTL)
- forceRefresh parameter for manual refresh button
- Updates channel name and thumbnail from API (resolves Phase 1 placeholder names)
- Three-step YouTube API pattern (3 quota units total)
- Filters Shorts at 180-second threshold
- Upserts to database with youtube_id conflict resolution
- Returns { videos, cached, fetchedAt } for UI to show cache status
  </action>
  <verify>
Deploy function locally for testing:
```bash
supabase functions serve fetch-channel-videos --env-file .env.local
```

Or test with curl after deployment:
```bash
curl -X POST 'http://localhost:54321/functions/v1/fetch-channel-videos' \
  -H 'Content-Type: application/json' \
  -d '{"channelId": "test-uuid", "youtubeChannelId": "UC_x5XG1OV2P6uZZ5FSM9Ttw"}'
```

Note: Actual deployment requires YOUTUBE_API_KEY secret set in Supabase.
  </verify>
  <done>Edge Function created that fetches videos from YouTube API, filters Shorts, caches in database, and returns top 20 long-form videos.</done>
</task>

<task type="auto">
  <name>Task 2: Set up Edge Function secrets (documentation)</name>
  <files>supabase/functions/fetch-channel-videos/README.md</files>
  <action>
Create README documenting required secrets and deployment:

```markdown
# fetch-channel-videos Edge Function

Fetches videos from a YouTube channel via the YouTube Data API v3.

## Required Secrets

Set these in Supabase Dashboard -> Project Settings -> Edge Functions -> Secrets:

| Secret | Source |
|--------|--------|
| YOUTUBE_API_KEY | Google Cloud Console -> APIs & Services -> Credentials |

SUPABASE_URL and SUPABASE_SERVICE_ROLE_KEY are automatically available.

## Setup Steps

1. **Create YouTube API Key**
   - Go to https://console.cloud.google.com/
   - Create a project (or use existing)
   - Enable "YouTube Data API v3" in APIs & Services -> Library
   - Create API key in APIs & Services -> Credentials
   - (Optional) Restrict key to YouTube Data API v3

2. **Set Secret in Supabase**
   ```bash
   supabase secrets set YOUTUBE_API_KEY=your_api_key_here
   ```
   Or via Dashboard: Project Settings -> Edge Functions -> Secrets

3. **Deploy Function**
   ```bash
   supabase functions deploy fetch-channel-videos
   ```

## Usage

POST /functions/v1/fetch-channel-videos

Request body:
```json
{
  "channelId": "uuid-from-channels-table",
  "youtubeChannelId": "UC_x5XG1OV2P6uZZ5FSM9Ttw",
  "forceRefresh": false
}
```

Response:
```json
{
  "videos": [...],
  "cached": true,
  "fetchedAt": "2026-01-23T12:00:00Z"
}
```

## Quota Usage

Each refresh uses 3 YouTube API quota units:
- channels.list: 1 unit
- playlistItems.list: 1 unit
- videos.list: 1 unit

Daily quota is 10,000 units = ~3,333 channel refreshes/day.
```
  </action>
  <verify>README exists at supabase/functions/fetch-channel-videos/README.md</verify>
  <done>Documentation created for Edge Function setup and deployment.</done>
</task>

</tasks>

<verification>
- [ ] supabase/functions/fetch-channel-videos/index.ts exists
- [ ] Function handles CORS preflight
- [ ] Function checks cache before calling YouTube API
- [ ] Function supports forceRefresh parameter
- [ ] Function filters videos by duration >= 180 seconds
- [ ] Function upserts videos with youtube_id conflict resolution
- [ ] Function updates channel name from API response
- [ ] README documents required secrets and setup
</verification>

<success_criteria>
Edge Function ready for deployment. Once YOUTUBE_API_KEY secret is set, function will fetch and cache channel videos from YouTube API.
</success_criteria>

<output>
After completion, create `.planning/phases/02-video-retrieval/02-02-SUMMARY.md`
</output>

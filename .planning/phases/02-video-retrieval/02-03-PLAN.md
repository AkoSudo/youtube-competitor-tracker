---
phase: 02-video-retrieval
plan: 03
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/hooks/useChannelVideos.ts
  - src/lib/videos.ts
autonomous: true

must_haves:
  truths:
    - "useChannelVideos hook fetches videos for a channel"
    - "Hook shows loading state during fetch"
    - "Hook handles errors gracefully"
    - "Manual refresh triggers forceRefresh"
    - "Cache status is available (cached, fetchedAt)"
  artifacts:
    - path: "src/hooks/useChannelVideos.ts"
      provides: "React hook for video fetching"
      exports: ["useChannelVideos"]
    - path: "src/lib/videos.ts"
      provides: "Video fetching function"
      exports: ["fetchChannelVideos"]
  key_links:
    - from: "src/hooks/useChannelVideos.ts"
      to: "src/lib/videos.ts"
      via: "import fetchChannelVideos"
      pattern: "import.*from.*videos"
    - from: "src/lib/videos.ts"
      to: "Edge Function"
      via: "supabase.functions.invoke"
      pattern: "functions\\.invoke"
---

<objective>
Create useChannelVideos hook and videos data layer for fetching channel videos.

Purpose: Data layer connects UI to Edge Function. Hook provides loading/error states and refresh capability. Pattern follows existing useChannels hook structure.

Output: useChannelVideos hook ready for ChannelDetailPage to consume.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-video-retrieval/02-RESEARCH.md

# Existing patterns
@src/hooks/useChannels.ts
@src/lib/channels.ts
@src/lib/types.ts
@src/lib/supabase.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create videos data layer</name>
  <files>src/lib/videos.ts</files>
  <action>
Create src/lib/videos.ts with function to fetch videos via Edge Function:

```typescript
import { supabase } from './supabase'
import type { Video } from './types'

interface FetchVideosResult {
  videos: Video[]
  cached: boolean
  fetchedAt: string
  error: string | null
}

/**
 * Fetch videos for a channel via Edge Function.
 * Handles caching automatically (24hr TTL).
 *
 * @param channelId - Internal UUID from channels table
 * @param youtubeChannelId - YouTube channel ID (UC...)
 * @param forceRefresh - Skip cache and fetch fresh data
 */
export async function fetchChannelVideos(
  channelId: string,
  youtubeChannelId: string,
  forceRefresh = false
): Promise<FetchVideosResult> {
  try {
    const { data, error } = await supabase.functions.invoke('fetch-channel-videos', {
      body: { channelId, youtubeChannelId, forceRefresh },
    })

    if (error) {
      return {
        videos: [],
        cached: false,
        fetchedAt: '',
        error: error.message || 'Failed to fetch videos',
      }
    }

    if (data.error) {
      return {
        videos: [],
        cached: false,
        fetchedAt: '',
        error: data.error,
      }
    }

    return {
      videos: data.videos || [],
      cached: data.cached || false,
      fetchedAt: data.fetchedAt || new Date().toISOString(),
      error: null,
    }
  } catch (err) {
    return {
      videos: [],
      cached: false,
      fetchedAt: '',
      error: err instanceof Error ? err.message : 'An unexpected error occurred',
    }
  }
}

/**
 * Get cached videos from database directly (for initial render before Edge Function responds).
 * This allows showing stale data while fresh data is being fetched.
 */
export async function getCachedVideos(channelId: string): Promise<Video[]> {
  const { data } = await supabase
    .from('videos')
    .select('*')
    .eq('channel_id', channelId)
    .gte('duration_seconds', 180)
    .order('published_at', { ascending: false })
    .limit(20)

  return data || []
}
```

Notes:
- Uses supabase.functions.invoke for Edge Function call
- Returns typed result with videos, cache status, and potential error
- Includes getCachedVideos for optimistic initial render
  </action>
  <verify>`npm run build` succeeds with no type errors.</verify>
  <done>videos.ts created with fetchChannelVideos and getCachedVideos functions.</done>
</task>

<task type="auto">
  <name>Task 2: Create useChannelVideos hook</name>
  <files>src/hooks/useChannelVideos.ts</files>
  <action>
Create src/hooks/useChannelVideos.ts following useChannels pattern:

```typescript
import { useState, useEffect, useCallback } from 'react'
import { fetchChannelVideos, getCachedVideos } from '../lib/videos'
import type { Video } from '../lib/types'

interface UseChannelVideosResult {
  videos: Video[]
  isLoading: boolean
  error: string | null
  cached: boolean
  fetchedAt: string | null
  refresh: () => Promise<void>
}

/**
 * Hook for fetching and managing videos for a single channel.
 *
 * @param channelId - Internal UUID from channels table
 * @param youtubeChannelId - YouTube channel ID (UC...)
 */
export function useChannelVideos(
  channelId: string | null,
  youtubeChannelId: string | null
): UseChannelVideosResult {
  const [videos, setVideos] = useState<Video[]>([])
  const [isLoading, setIsLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)
  const [cached, setCached] = useState(false)
  const [fetchedAt, setFetchedAt] = useState<string | null>(null)

  // Load videos (with optional force refresh)
  const loadVideos = useCallback(
    async (forceRefresh = false) => {
      if (!channelId || !youtubeChannelId) return

      setIsLoading(true)
      setError(null)

      // Show cached data immediately while fetching fresh
      if (!forceRefresh) {
        const cachedVideos = await getCachedVideos(channelId)
        if (cachedVideos.length > 0) {
          setVideos(cachedVideos)
        }
      }

      // Fetch from Edge Function
      const result = await fetchChannelVideos(channelId, youtubeChannelId, forceRefresh)

      if (result.error) {
        setError(result.error)
      } else {
        setVideos(result.videos)
        setCached(result.cached)
        setFetchedAt(result.fetchedAt)
      }

      setIsLoading(false)
    },
    [channelId, youtubeChannelId]
  )

  // Initial fetch on mount or when channel changes
  useEffect(() => {
    if (channelId && youtubeChannelId) {
      loadVideos(false)
    }
  }, [channelId, youtubeChannelId, loadVideos])

  // Manual refresh (forces fresh fetch from YouTube API)
  const refresh = useCallback(async () => {
    await loadVideos(true)
  }, [loadVideos])

  return {
    videos,
    isLoading,
    error,
    cached,
    fetchedAt,
    refresh,
  }
}
```

Key features:
- Takes channelId and youtubeChannelId as parameters
- Shows cached data immediately while fetching fresh
- Provides refresh() for manual refresh button
- Exposes cached status and fetchedAt for UI display
- Follows same pattern as useChannels hook
  </action>
  <verify>`npm run build` succeeds with no type errors.</verify>
  <done>useChannelVideos hook created with videos, loading, error, cache status, and refresh capability.</done>
</task>

</tasks>

<verification>
- [ ] src/lib/videos.ts exists with fetchChannelVideos and getCachedVideos
- [ ] src/hooks/useChannelVideos.ts exists with useChannelVideos hook
- [ ] Hook returns videos, isLoading, error, cached, fetchedAt, refresh
- [ ] Hook shows cached data before fresh fetch completes
- [ ] Hook supports force refresh via refresh() function
- [ ] `npm run build` succeeds
</verification>

<success_criteria>
Data layer complete. useChannelVideos hook ready for ChannelDetailPage to consume with loading states, error handling, cache status, and manual refresh.
</success_criteria>

<output>
After completion, create `.planning/phases/02-video-retrieval/02-03-SUMMARY.md`
</output>

---
phase: 01-foundation
plan: 05
type: execute
wave: 2
depends_on: ["01-03"]
files_modified:
  - src/hooks/useChannels.ts
  - src/lib/channels.ts
autonomous: true

must_haves:
  truths:
    - "Channels can be fetched from database"
    - "New channel can be added"
    - "Channel can be deleted"
    - "Changes sync in real-time across tabs"
  artifacts:
    - path: "src/hooks/useChannels.ts"
      provides: "React hook for channel data + realtime"
      exports: ["useChannels"]
      min_lines: 50
    - path: "src/lib/channels.ts"
      provides: "Channel CRUD operations"
      exports: ["fetchChannels", "addChannel", "deleteChannel"]
      min_lines: 30
  key_links:
    - from: "src/hooks/useChannels.ts"
      to: "src/lib/supabase.ts"
      via: "realtime subscription"
      pattern: "supabase.*channel.*subscribe"
    - from: "src/lib/channels.ts"
      to: "src/lib/supabase.ts"
      via: "database operations"
      pattern: "supabase.*from.*channels"
---

<objective>
Implement channel CRUD operations and real-time synchronization hook.

Purpose: REQ-CH-005 requires real-time sync within 2 seconds. This plan creates the data layer with Supabase real-time subscriptions.
Output: useChannels hook that provides live-updating channel list with add/delete operations.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-03-SUMMARY.md (if exists)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Channel CRUD Functions</name>
  <files>
    src/lib/channels.ts
  </files>
  <action>
    Create src/lib/channels.ts with typed CRUD operations:
    ```typescript
    import { supabase } from './supabase'
    import type { Channel, ChannelInsert, DbResult } from './types'

    /**
     * Fetch all channels ordered by creation date (newest first).
     */
    export async function fetchChannels(): Promise<DbResult<Channel[]>> {
      const { data, error } = await supabase
        .from('channels')
        .select('*')
        .order('created_at', { ascending: false })

      if (error) {
        console.error('Error fetching channels:', error)
        return { data: null, error: error.message }
      }

      return { data: data as Channel[], error: null }
    }

    /**
     * Add a new channel to the database.
     * Returns error if youtube_id already exists (UNIQUE constraint).
     */
    export async function addChannel(channel: ChannelInsert): Promise<DbResult<Channel>> {
      const { data, error } = await supabase
        .from('channels')
        .insert(channel)
        .select()
        .single()

      if (error) {
        console.error('Error adding channel:', error)

        // Handle duplicate youtube_id (UNIQUE constraint violation)
        if (error.code === '23505') {
          return { data: null, error: 'This channel is already being tracked.' }
        }

        return { data: null, error: error.message }
      }

      return { data: data as Channel, error: null }
    }

    /**
     * Delete a channel by ID.
     * Related videos and ideas will be cascade deleted by database FK constraints.
     */
    export async function deleteChannel(id: string): Promise<DbResult<null>> {
      const { error } = await supabase
        .from('channels')
        .delete()
        .eq('id', id)

      if (error) {
        console.error('Error deleting channel:', error)
        return { data: null, error: error.message }
      }

      return { data: null, error: null }
    }

    /**
     * Check if a channel with the given youtube_id exists.
     */
    export async function channelExists(youtubeId: string): Promise<boolean> {
      const { data } = await supabase
        .from('channels')
        .select('id')
        .eq('youtube_id', youtubeId)
        .single()

      return data !== null
    }
    ```
  </action>
  <verify>
    TypeScript compiles: `npx tsc --noEmit`
    File exists with all exports
  </verify>
  <done>
    CRUD functions created: fetchChannels, addChannel, deleteChannel, channelExists
  </done>
</task>

<task type="auto">
  <name>Task 2: Create useChannels Hook with Real-time Sync</name>
  <files>
    src/hooks/useChannels.ts
  </files>
  <action>
    Create src/hooks directory if not exists.

    Create src/hooks/useChannels.ts:
    ```typescript
    import { useState, useEffect, useCallback } from 'react'
    import { supabase } from '../lib/supabase'
    import { fetchChannels, addChannel, deleteChannel } from '../lib/channels'
    import type { Channel, ChannelInsert } from '../lib/types'

    interface UseChannelsResult {
      channels: Channel[]
      isLoading: boolean
      error: string | null
      addChannel: (channel: ChannelInsert) => Promise<{ success: boolean; error?: string }>
      deleteChannel: (id: string) => Promise<{ success: boolean; error?: string }>
      refresh: () => Promise<void>
    }

    /**
     * Hook for managing channels with real-time updates.
     * Subscribes to Supabase real-time changes on the channels table.
     */
    export function useChannels(): UseChannelsResult {
      const [channels, setChannels] = useState<Channel[]>([])
      const [isLoading, setIsLoading] = useState(true)
      const [error, setError] = useState<string | null>(null)

      // Initial fetch
      const loadChannels = useCallback(async () => {
        setIsLoading(true)
        setError(null)

        const result = await fetchChannels()

        if (result.error) {
          setError(result.error)
        } else {
          setChannels(result.data || [])
        }

        setIsLoading(false)
      }, [])

      // Set up real-time subscription
      useEffect(() => {
        // Load initial data
        loadChannels()

        // Subscribe to real-time changes
        // Use unique channel name to avoid "already subscribed" errors
        const channelName = `channels-realtime-${Date.now()}`

        const subscription = supabase
          .channel(channelName)
          .on(
            'postgres_changes',
            {
              event: '*',
              schema: 'public',
              table: 'channels',
            },
            (payload) => {
              if (payload.eventType === 'INSERT') {
                // Add new channel to the beginning (newest first)
                const newChannel = payload.new as Channel
                setChannels((prev) => [newChannel, ...prev])
              } else if (payload.eventType === 'DELETE') {
                // Remove deleted channel
                const deletedId = payload.old.id
                setChannels((prev) => prev.filter((c) => c.id !== deletedId))
              } else if (payload.eventType === 'UPDATE') {
                // Update existing channel
                const updatedChannel = payload.new as Channel
                setChannels((prev) =>
                  prev.map((c) => (c.id === updatedChannel.id ? updatedChannel : c))
                )
              }
            }
          )
          .subscribe((status) => {
            if (status === 'SUBSCRIBED') {
              console.log('Real-time subscription active for channels')
            }
          })

        // Cleanup subscription on unmount
        return () => {
          supabase.removeChannel(subscription)
        }
      }, [loadChannels])

      // Add channel action
      const handleAddChannel = useCallback(
        async (channel: ChannelInsert): Promise<{ success: boolean; error?: string }> => {
          const result = await addChannel(channel)

          if (result.error) {
            return { success: false, error: result.error }
          }

          // Note: Real-time will handle adding to state
          return { success: true }
        },
        []
      )

      // Delete channel action
      const handleDeleteChannel = useCallback(
        async (id: string): Promise<{ success: boolean; error?: string }> => {
          const result = await deleteChannel(id)

          if (result.error) {
            return { success: false, error: result.error }
          }

          // Note: Real-time will handle removing from state
          return { success: true }
        },
        []
      )

      return {
        channels,
        isLoading,
        error,
        addChannel: handleAddChannel,
        deleteChannel: handleDeleteChannel,
        refresh: loadChannels,
      }
    }
    ```
  </action>
  <verify>
    TypeScript compiles: `npx tsc --noEmit`
    Hook exports useChannels function
  </verify>
  <done>
    useChannels hook created with real-time subscription, add/delete operations
  </done>
</task>

</tasks>

<verification>
1. `src/lib/channels.ts` exports fetchChannels, addChannel, deleteChannel
2. `src/hooks/useChannels.ts` exports useChannels hook
3. TypeScript compiles without errors
4. Hook subscribes to real-time changes (can verify in browser console)
5. CRUD operations use typed parameters and returns
</verification>

<success_criteria>
- fetchChannels returns Channel[]
- addChannel handles duplicate youtube_id gracefully
- deleteChannel removes channel by ID
- useChannels hook:
  - Returns channels, isLoading, error
  - Provides addChannel, deleteChannel actions
  - Subscribes to real-time updates
  - Cleans up subscription on unmount
- No TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-05-SUMMARY.md`
</output>
